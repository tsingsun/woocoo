{{/* gotype: entgo.io/ent/entc/gen.Type */}}
# type of the {{$.Name}}
type {{$.Name}} {
{{- if $.ID}}
    {{printf "%s: ID!"  $.ID.Name}}
{{- end}}
{{- range $f:=$.Fields}}
    {{- $nn:=""}}
    {{- if not $f.Optional}}
        {{- $nn = "!"}}
    {{- end}}
    {{- if $f.IsString}}
    {{printf "%s: String%s" $f.Column.Name $nn}}
    {{- else}}{{if $f.IsTime}}
    {{printf "%s: Time%s" $f.Column.Name $nn}}
    {{- else}}{{if $f.IsBool}}
    {{printf "%s: Boolean%s" $f.Column.Name $nn}}
    {{- else}}{{if $f.IsInt}}
    {{printf "%s: Int%s" $f.Column.Name $nn}}
    {{- else}}{{if $f.Type.Type.Float}}
    {{printf "%s: Float%s" $f.Column.Name $nn}}
    {{- else}}{{printf "%s: %s%s"  $f.Column.Name (pascal $f.Column.Type.String) $nn}}
    {{end}}{{- end}}{{end}}{{end}}{{end}}
{{- end}}
}

# relay support
type {{$.Name}}Edge {
    node: {{$.Name}}
    cursor: Cursor!
}

type {{$.Name}}Connection {
    totalCount: Int!
    pageInfo: PageInfo!
    edges: [{{$.Name}}Edge]
}

# These enums are matched the entgql annotations in the ent/schema.
enum {{$.Name}}OrderField {
{{- if $.ID}}
    {{$.ID.Name}}
{{- end}}
{{- range $f:=$.Fields}}
    {{- $order := entgqlOrderField $f }}
    {{- if $order }}
    {{printf "%s" $f.Name}}
    {{- end}}
{{- end}}
}

input {{$.Name}}Order {
    direction: OrderDirection!
    field: {{$.Name}}OrderField
}