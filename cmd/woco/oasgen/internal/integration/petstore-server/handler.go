// Code generated by woco, DO NOT EDIT.

package petstore

import (
	"errors"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/tsingsun/woocoo/pkg/gds"
	"github.com/tsingsun/woocoo/web/handler"
)

// RegisterPetHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterPetHandlers(router *gin.RouterGroup, si PetService) {
	router.POST("/pet", wrapAddPet(si))
	router.DELETE("/pet/:petId", wrapDeletePet(si))
	router.GET("/pet/findByStatus", wrapFindPetsByStatus(si))
	router.GET("/pet/findByTags", wrapFindPetsByTags(si))
	router.GET("/pet/:petId", wrapGetPetById(si))
	router.PUT("/pet", wrapUpdatePet(si))
	router.POST("/pet/:petId", wrapUpdatePetWithForm(si))
	router.POST("/pet/:petId/uploadImage", wrapUploadFile(si))
}

// RegisterStoreHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterStoreHandlers(router *gin.RouterGroup, si StoreService) {
	router.DELETE("/store/order/:orderId", wrapDeleteOrder(si))
	router.GET("/store/inventory", wrapGetInventory(si))
	router.GET("/store/order/:orderId", wrapGetOrderById(si))
	router.POST("/store/order", wrapPlaceOrder(si))
}

// RegisterUserHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterUserHandlers(router *gin.RouterGroup, si UserService) {
	router.POST("/user", wrapCreateUser(si))
	router.POST("/user/profile", wrapCreateUserProfile(si))
	router.POST("/user/createWithArray", wrapCreateUsersWithArrayInput(si))
	router.POST("/user/createWithList", wrapCreateUsersWithListInput(si))
	router.DELETE("/user/:username", wrapDeleteUser(si))
	router.GET("/user/:username", wrapGetUserByName(si))
	router.GET("/user/login", wrapLoginUser(si))
	router.GET("/user/logout", wrapLogoutUser(si))
	router.PUT("/user/:username", wrapUpdateUser(si))
}

func wrapAddPet(si PetService) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req AddPetRequest
		if err := c.ShouldBind(&req); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		resp, err := si.AddPet(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json", "application/xml"})
	}
}

func wrapDeletePet(si PetService) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req DeletePetRequest
		if err := c.ShouldBindUri(&req.PathParams); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		if err := c.ShouldBindHeader(&req.HeaderParams); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		err := si.DeletePet(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
	}
}

func wrapFindPetsByStatus(si PetService) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req FindPetsByStatusRequest
		if err := c.ShouldBindQuery(&req); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		resp, err := si.FindPetsByStatus(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json", "application/xml"})
	}
}

func wrapFindPetsByTags(si PetService) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req FindPetsByTagsRequest
		if err := c.ShouldBindQuery(&req); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		resp, err := si.FindPetsByTags(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json", "application/xml"})
	}
}

func wrapGetPetById(si PetService) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req GetPetByIdRequest
		if err := c.ShouldBindUri(&req); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		resp, err := si.GetPetById(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
		if resp == nil {
			handler.AbortWithError(c, http.StatusBadRequest, errors.New("Pet not found"))
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json", "application/xml"})
	}
}

func wrapUpdatePet(si PetService) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req UpdatePetRequest
		if err := c.ShouldBind(&req); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		resp, err := si.UpdatePet(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
		if resp == nil {
			handler.AbortWithError(c, http.StatusBadRequest, errors.New("Pet not found"))
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json", "application/xml"})
	}
}

func wrapUpdatePetWithForm(si PetService) func(c *gin.Context) {
	return func(c *gin.Context) {
		req := UpdatePetWithFormRequest{
			QueryParams: UpdatePetWithFormRequestQueryParams{
				Timestamp: gds.Ptr(int64(1234567890)),
			},
		}
		if err := c.ShouldBindUri(&req.PathParams); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		if err := c.ShouldBindQuery(&req.QueryParams); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		if err := c.ShouldBind(&req.Body); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		err := si.UpdatePetWithForm(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
	}
}

func wrapUploadFile(si PetService) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req UploadFileRequest
		if err := c.ShouldBindUri(&req.PathParams); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		if err := c.ShouldBind(&req.Body); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		resp, err := si.UploadFile(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json"})
	}
}

func wrapDeleteOrder(si StoreService) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req DeleteOrderRequest
		if err := c.ShouldBindUri(&req); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		err := si.DeleteOrder(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
	}
}

func wrapGetInventory(si StoreService) func(c *gin.Context) {
	return func(c *gin.Context) {
		resp, err := si.GetInventory(c)
		if err != nil {
			c.Error(err)
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json"})
	}
}

func wrapGetOrderById(si StoreService) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req GetOrderByIdRequest
		if err := c.ShouldBindUri(&req); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		resp, err := si.GetOrderById(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
		if resp == nil {
			handler.AbortWithError(c, http.StatusBadRequest, errors.New("Order not found"))
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json", "application/xml"})
	}
}

func wrapPlaceOrder(si StoreService) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req PlaceOrderRequest
		if err := c.ShouldBind(&req); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		resp, err := si.PlaceOrder(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json", "application/xml"})
	}
}

func wrapCreateUser(si UserService) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req CreateUserRequest
		if err := c.ShouldBind(&req); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		resp, err := si.CreateUser(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json"})
	}
}

func wrapCreateUserProfile(si UserService) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req CreateUserProfileRequest
		if err := c.ShouldBind(&req); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		resp, err := si.CreateUserProfile(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json"})
	}
}

func wrapCreateUsersWithArrayInput(si UserService) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req CreateUsersWithArrayInputRequest
		if err := c.ShouldBind(&req); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		err := si.CreateUsersWithArrayInput(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
	}
}

func wrapCreateUsersWithListInput(si UserService) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req CreateUsersWithListInputRequest
		if err := c.ShouldBind(&req); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		err := si.CreateUsersWithListInput(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
	}
}

func wrapDeleteUser(si UserService) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req DeleteUserRequest
		if err := c.ShouldBindUri(&req); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		err := si.DeleteUser(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
	}
}

func wrapGetUserByName(si UserService) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req GetUserByNameRequest
		if err := c.ShouldBindUri(&req); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		resp, err := si.GetUserByName(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
		if resp == nil {
			handler.AbortWithError(c, http.StatusBadRequest, errors.New("User not found"))
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json", "application/xml"})
	}
}

func wrapLoginUser(si UserService) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req LoginUserRequest
		if err := c.ShouldBindQuery(&req); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		resp, err := si.LoginUser(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json", "application/xml"})
	}
}

func wrapLogoutUser(si UserService) func(c *gin.Context) {
	return func(c *gin.Context) {
		err := si.LogoutUser(c)
		if err != nil {
			c.Error(err)
			return
		}
	}
}

func wrapUpdateUser(si UserService) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req UpdateUserRequest
		if err := c.ShouldBindUri(&req.PathParams); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		if err := c.ShouldBind(&req.Body); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		err := si.UpdateUser(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
	}
}
