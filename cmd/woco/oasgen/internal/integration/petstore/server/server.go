// Code generated by woco, DO NOT EDIT.

package server

import (
	"errors"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/tsingsun/woocoo/cmd/woco/oasgen/internal/integration/petstore"
	"github.com/tsingsun/woocoo/web/handler"
)

// RegisterPetHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterPetHandlers(router *gin.Engine, si petstore.PetServer) *gin.Engine {
	router.POST("/pet", wrapAddPet(si))
	router.DELETE("/pet/:petId", wrapDeletePet(si))
	router.GET("/pet/findByStatus", wrapFindPetsByStatus(si))
	router.GET("/pet/findByTags", wrapFindPetsByTags(si))
	router.GET("/pet/:petId", wrapGetPetById(si))
	router.PUT("/pet", wrapUpdatePet(si))
	router.POST("/pet/:petId", wrapUpdatePetWithForm(si))
	router.POST("/pet/:petId/uploadImage", wrapUploadFile(si))
	return router
}

func wrapAddPet(si petstore.PetServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req petstore.AddPetRequest
		if err := c.ShouldBind(&req.Body); err != nil {
			c.Status(http.StatusBadRequest)
			c.Error(err)
			return
		}
		resp, err := si.AddPet(c, &req)
		if err != nil {
			c.Status(http.StatusInternalServerError)
			c.Error(err)
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json", "application/xml"})
	}
}

func wrapDeletePet(si petstore.PetServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req petstore.DeletePetRequest
		if err := c.ShouldBindUri(&req.UriParams); err != nil {
			c.Status(http.StatusBadRequest)
			c.Error(err)
			return
		}
		if err := c.ShouldBindHeader(&req.HeaderParams); err != nil {
			c.Status(http.StatusBadRequest)
			c.Error(err)
			return
		}
		err := si.DeletePet(c, &req)
		if err != nil {
			c.Status(http.StatusInternalServerError)
			c.Error(err)
			return
		}
	}
}

func wrapFindPetsByStatus(si petstore.PetServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req petstore.FindPetsByStatusRequest
		if err := c.ShouldBind(&req.Body); err != nil {
			c.Status(http.StatusBadRequest)
			c.Error(err)
			return
		}
		resp, err := si.FindPetsByStatus(c, &req)
		if err != nil {
			c.Status(http.StatusInternalServerError)
			c.Error(err)
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json", "application/xml"})
	}
}

func wrapFindPetsByTags(si petstore.PetServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req petstore.FindPetsByTagsRequest
		if err := c.ShouldBind(&req.Body); err != nil {
			c.Status(http.StatusBadRequest)
			c.Error(err)
			return
		}
		resp, err := si.FindPetsByTags(c, &req)
		if err != nil {
			c.Status(http.StatusInternalServerError)
			c.Error(err)
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json", "application/xml"})
	}
}

func wrapGetPetById(si petstore.PetServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req petstore.GetPetByIdRequest
		if err := c.ShouldBindUri(&req.UriParams); err != nil {
			c.Status(http.StatusBadRequest)
			c.Error(err)
			return
		}
		resp, err := si.GetPetById(c, &req)
		if err != nil {
			c.Status(http.StatusInternalServerError)
			c.Error(err)
			return
		}
		if resp == nil {
			c.Status(http.StatusNotFound)
			c.Error(errors.New("Pet not found"))
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json", "application/xml"})
	}
}

func wrapUpdatePet(si petstore.PetServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req petstore.UpdatePetRequest
		if err := c.ShouldBind(&req.Body); err != nil {
			c.Status(http.StatusBadRequest)
			c.Error(err)
			return
		}
		resp, err := si.UpdatePet(c, &req)
		if err != nil {
			c.Status(http.StatusInternalServerError)
			c.Error(err)
			return
		}
		if resp == nil {
			c.Status(http.StatusNotFound)
			c.Error(errors.New("Pet not found"))
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json", "application/xml"})
	}
}

func wrapUpdatePetWithForm(si petstore.PetServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req petstore.UpdatePetWithFormRequest
		if err := c.ShouldBindUri(&req.UriParams); err != nil {
			c.Status(http.StatusBadRequest)
			c.Error(err)
			return
		}
		if err := c.ShouldBind(&req.Body); err != nil {
			c.Status(http.StatusBadRequest)
			c.Error(err)
			return
		}
		err := si.UpdatePetWithForm(c, &req)
		if err != nil {
			c.Status(http.StatusInternalServerError)
			c.Error(err)
			return
		}
	}
}

func wrapUploadFile(si petstore.PetServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req petstore.UploadFileRequest
		if err := c.ShouldBindUri(&req.UriParams); err != nil {
			c.Status(http.StatusBadRequest)
			c.Error(err)
			return
		}
		if err := c.ShouldBind(&req.Body); err != nil {
			c.Status(http.StatusBadRequest)
			c.Error(err)
			return
		}
		resp, err := si.UploadFile(c, &req)
		if err != nil {
			c.Status(http.StatusInternalServerError)
			c.Error(err)
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json"})
	}
}

// RegisterStoreHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterStoreHandlers(router *gin.Engine, si petstore.StoreServer) *gin.Engine {
	router.DELETE("/store/order/:orderId", wrapDeleteOrder(si))
	router.GET("/store/inventory", wrapGetInventory(si))
	router.GET("/store/order/:orderId", wrapGetOrderById(si))
	router.POST("/store/order", wrapPlaceOrder(si))
	return router
}

func wrapDeleteOrder(si petstore.StoreServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req petstore.DeleteOrderRequest
		if err := c.ShouldBindUri(&req.UriParams); err != nil {
			c.Status(http.StatusBadRequest)
			c.Error(err)
			return
		}
		err := si.DeleteOrder(c, &req)
		if err != nil {
			c.Status(http.StatusInternalServerError)
			c.Error(err)
			return
		}
	}
}

func wrapGetInventory(si petstore.StoreServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		resp, err := si.GetInventory(c)
		if err != nil {
			c.Status(http.StatusInternalServerError)
			c.Error(err)
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json"})
	}
}

func wrapGetOrderById(si petstore.StoreServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req petstore.GetOrderByIdRequest
		if err := c.ShouldBindUri(&req.UriParams); err != nil {
			c.Status(http.StatusBadRequest)
			c.Error(err)
			return
		}
		resp, err := si.GetOrderById(c, &req)
		if err != nil {
			c.Status(http.StatusInternalServerError)
			c.Error(err)
			return
		}
		if resp == nil {
			c.Status(http.StatusNotFound)
			c.Error(errors.New("Order not found"))
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json", "application/xml"})
	}
}

func wrapPlaceOrder(si petstore.StoreServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req petstore.PlaceOrderRequest
		if err := c.ShouldBind(&req.Body); err != nil {
			c.Status(http.StatusBadRequest)
			c.Error(err)
			return
		}
		resp, err := si.PlaceOrder(c, &req)
		if err != nil {
			c.Status(http.StatusInternalServerError)
			c.Error(err)
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json", "application/xml"})
	}
}

// RegisterUserHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterUserHandlers(router *gin.Engine, si petstore.UserServer) *gin.Engine {
	router.POST("/user", wrapCreateUser(si))
	router.POST("/user/createWithArray", wrapCreateUsersWithArrayInput(si))
	router.POST("/user/createWithList", wrapCreateUsersWithListInput(si))
	router.DELETE("/user/:username", wrapDeleteUser(si))
	router.GET("/user/:username", wrapGetUserByName(si))
	router.GET("/user/login", wrapLoginUser(si))
	router.GET("/user/logout", wrapLogoutUser(si))
	router.PUT("/user/:username", wrapUpdateUser(si))
	return router
}

func wrapCreateUser(si petstore.UserServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req petstore.CreateUserRequest
		if err := c.ShouldBind(&req.Body); err != nil {
			c.Status(http.StatusBadRequest)
			c.Error(err)
			return
		}
		err := si.CreateUser(c, &req)
		if err != nil {
			c.Status(http.StatusInternalServerError)
			c.Error(err)
			return
		}
	}
}

func wrapCreateUsersWithArrayInput(si petstore.UserServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		err := si.CreateUsersWithArrayInput(c)
		if err != nil {
			c.Status(http.StatusInternalServerError)
			c.Error(err)
			return
		}
	}
}

func wrapCreateUsersWithListInput(si petstore.UserServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		err := si.CreateUsersWithListInput(c)
		if err != nil {
			c.Status(http.StatusInternalServerError)
			c.Error(err)
			return
		}
	}
}

func wrapDeleteUser(si petstore.UserServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req petstore.DeleteUserRequest
		if err := c.ShouldBindUri(&req.UriParams); err != nil {
			c.Status(http.StatusBadRequest)
			c.Error(err)
			return
		}
		err := si.DeleteUser(c, &req)
		if err != nil {
			c.Status(http.StatusInternalServerError)
			c.Error(err)
			return
		}
	}
}

func wrapGetUserByName(si petstore.UserServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req petstore.GetUserByNameRequest
		if err := c.ShouldBindUri(&req.UriParams); err != nil {
			c.Status(http.StatusBadRequest)
			c.Error(err)
			return
		}
		resp, err := si.GetUserByName(c, &req)
		if err != nil {
			c.Status(http.StatusInternalServerError)
			c.Error(err)
			return
		}
		if resp == nil {
			c.Status(http.StatusNotFound)
			c.Error(errors.New("User not found"))
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json", "application/xml"})
	}
}

func wrapLoginUser(si petstore.UserServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req petstore.LoginUserRequest
		if err := c.ShouldBind(&req.Body); err != nil {
			c.Status(http.StatusBadRequest)
			c.Error(err)
			return
		}
		resp, err := si.LoginUser(c, &req)
		if err != nil {
			c.Status(http.StatusInternalServerError)
			c.Error(err)
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json", "application/xml"})
	}
}

func wrapLogoutUser(si petstore.UserServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		err := si.LogoutUser(c)
		if err != nil {
			c.Status(http.StatusInternalServerError)
			c.Error(err)
			return
		}
	}
}

func wrapUpdateUser(si petstore.UserServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req petstore.UpdateUserRequest
		if err := c.ShouldBindUri(&req.UriParams); err != nil {
			c.Status(http.StatusBadRequest)
			c.Error(err)
			return
		}
		if err := c.ShouldBind(&req.Body); err != nil {
			c.Status(http.StatusBadRequest)
			c.Error(err)
			return
		}
		err := si.UpdateUser(c, &req)
		if err != nil {
			c.Status(http.StatusInternalServerError)
			c.Error(err)
			return
		}
	}
}
